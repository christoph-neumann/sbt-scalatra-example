import sbt._
import Keys._

object SbtTestBuild extends Build {
	lazy val root = Project("root", file(".")) settings(
		// Do not include the scala version or the project version in the artifact name
		artifactName := { (config: String, module: ModuleID, artifact: Artifact) =>
			artifact.name + "." + artifact.extension
		},

		// Custom tasks
		cleanAll <<= cleanAllTask,
		cleanAll <<= cleanAll.dependsOn(clean in Compile),
		dist <<= distTask,
		dist <<= dist.dependsOn(packageBin in Compile)
	)

	val cleanAll = TaskKey[Unit]("clean-all", "Removes all autogenerated files.")
	def cleanAllTask = (streams, baseDirectory) map {
		(out, basedir) => {
			IO.delete(basedir / "project" / "boot")
			IO.delete(basedir / "project" / "target")
			IO.delete(basedir / "target")
		}
	}

	val dist = TaskKey[Unit]("dist", "Produce a distribution.")
	def distTask = (streams, baseDirectory, externalDependencyClasspath in Runtime, artifactPath in makePom) map {
		(out, basedir, deps, aPath) => {
			val scripts = new File(basedir, "src/main/scripts")
			val dist = new File(basedir, "target/dist")
			val lib = new File(dist, "lib")
			val artifacts = aPath.getParentFile

			// Copy everything in the scripts directory and make all the shell scripts executable.
			IO.copyDirectory(scripts, dist)
			for ( file <- dist.listFiles; if (file.isFile && file.name.endsWith("sh")) ) yield {
				file.setExecutable(true)
			}

			// Get the jar that was produced from the "package" task and copy it into the "lib"
			// directory
			for ( file <- artifacts.listFiles; if (file.isFile && file.name.endsWith(".jar")) ) yield {
				out.log.info("Copying "+ file.getName)
				IO.copyFile(file, new File(lib, file.getName))
			}

			// Copy all the dependencies into the "lib" directory.
			deps.map(_.data) foreach { file =>
				out.log.info("Copying "+ file.getName)
				IO.copyFile(file, new File(lib, file.getName))
			}
		}
	}
}
